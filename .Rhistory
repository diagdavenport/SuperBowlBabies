# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
dim(edges)
dim(M)
length(unique(c(edges$V1, edges$V2)))
dim(power.iter(t(M), rep(1,nrow(M)), 3))
power.iter(t(M), rep(1,nrow(M)), 3)[1]
power.iter(t(M), rep(1,nrow(M)), 3)[7]
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 3))
v<- v/sum(v)
head(v[order(v[,1],)])
?sort
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 3))
v<- v/sum(v)
head(sort(v, decreasing = TRUE))
# What are the top two eigen values?
#print(eigen(t(M))$values[1:2])
# The eigen command times out on my machine
# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
v
head(v)
head(sort(v, decreasing = TRUE))
head(order(v, decreasing = TRUE))
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 3))
v<- v/sum(v)
sort(v, decreasing = TRUE)[1:3]
# What are the top two eigen values?
#print(eigen(t(M))$values[1:2])
# The eigen command times out on my machine
# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
class(v)
as.vector(v)
head(v)
as.data.frame(v)
head(as.data.frame(v))
head(as.data.frame(v)[order(v$V1, )])
head(sort(as.data.frame(v)))
as.data.frame(v)[order(v$V1),]
df<- as.data.frame(v)
df[order(df$V1),]
head(df[order(df$V1),])
?subset
head(v)
subset(v, v[,1] > .08)
subset(v, v[,1] > .008)
subset(v, v[,1]= 0.009827646)
subset(v, v[,1]== 0.009827646)
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 3))
v<- v/sum(v)
sort(v, decreasing = TRUE)[1:3]
# What are the top two eigen values?
#print(eigen(t(M))$values[1:2])
# The eigen command times out on my machine
# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
subset(v, v[,1] == max(v[,1]))
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 50))
v<- v/sum(v)
sort(v, decreasing = TRUE)[1:3]
# What are the top two eigen values?
#print(eigen(t(M))$values[1:2])
# The eigen command times out on my machine
# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
subset(v, v[,1] == max(v[,1]))
read.table("data/edges.txt") -> edges
p <- .15
min.page <- min(edges)
max.page <- max(edges)
edges <- rbind(edges, data.frame(V1=min.page:max.page, V2=min.page:max.page))
A <- as.matrix(as_adjacency_matrix(graph_from_data_frame(edges)))
A <- A/rowSums(A)
B <- matrix(1/nrow(A) , nrow = nrow(A) , ncol = ncol(A))
M <- (1-p)*A + p*B
# Find the dominant eigenvector for each value of p
v <- (power.iter(t(M), rep(1,nrow(M)), 100))
v<- v/sum(v)
# What are the top two eigen values?
#print(eigen(t(M))$values[1:2])
# The eigen command times out on my machine
# capture the difference
#eigen.dist[p] <- eigen(t(M))$values[1] - eigen(t(M))$values[2]
subset(v, v[,1] == max(v[,1]))
knitr::opts_chunk$set(echo = TRUE)
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if method == "reimann" {
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
Fapprox(10000, "reimann")
Fapprox(10000, "trapezoid")
Fapprox(10000, "balsj")
Fapprox(1000, "trapezoid")
Fapprox(100, "trapezoid")
Fapprox(10, "trapezoid")
Fapprox(1, "trapezoid")
Fapprox(5, "trapezoid")
Fapprox(4, "trapezoid")
Fapprox(3, "trapezoid")
Fapprox(2, "trapezoid")
Fapprox(1, "trapezoid")
n.vec <- c(10, 10^2 10^3, 10^4)
n.vec <- c(10, 10^2 10^3, 10^4)
n.vec <- c(10, 10^2, 10^3, 10^4)
Fapprox(n, "riemann")
Fapprox(n.vec, "riemann")
?sapply
sapply(c(10,100,1000), Fapprox)
sapply(c(10,100,1000), Fapprox, "riemann")
class(sapply(c(10,100,1000), Fapprox, "riemann"))
class(vapply(c(10,100,1000), Fapprox, "riemann")
)
class(vapply(c(10,100,1000), Fapprox, "riemann"))
class(lapply(c(10,100,1000), Fapprox, "riemann"))
class(lapply(c(10,100,1000), Fapprox, "riemann", 3))
class(lapply(c(10,100,1000), Fapprox, 3, "riemann"))
class(lapply(c(10,100,1000), Fapprox, c(1, 2, 3), "riemann"))
class(sapply(c(10,100,1000), Fapprox, "riemann"))
class(sapply(c(10,100,1000), Fapprox, "riemann")[1,])
class(lapply(c(10,100,1000), Fapprox, "riemann"))
unlist(lapply(c(10,100,1000), Fapprox, "riemann"))
unlist(lapply(c(10,100,1000), Fapprox, "riemann")[1,])
lapply(c(10,100,1000), Fapprox, "riemann")
unlist(lapply(c(10,100,1000), Fapprox, "riemann"))
unlist(lapply(c(10,100,1000), Fapprox, "riemann")$value)
unlist(lapply(c(10,100,1000), Fapprox, "riemann"))$value
unlist(lapply(c(10,100,1000), Fapprox, "riemann"))
(lapply(c(10,100,1000), Fapprox, "riemann"))
(sapply(c(10,100,1000), Fapprox, "riemann"))
(sapply(c(10,100,1000), Fapprox, "riemann"))[1,]
unlist((sapply(c(10,100,1000), Fapprox, "riemann"))[1,])
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "riemann"))[1,])
trap.results <- unlist((sapply(n.vec, Fapprox, "trapezoid"))[1,])
sapply(n.vec, Fapprox, "trapezoid")
(sapply(n.vec, Fapprox, "riemann")
)
(sapply(n.vec, Fapprox, "useR")
)
options(digits = 16)
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
R.resuls
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
trap.results
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "riemann"))[1,])
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- (sapply(n.vec, Fapprox, "useR"))
plot(n.vec, riem.results)
points(n.vec, trap.results, pch = 5)
points(n.vec, R.resuls, pch = 7)
R.resuls
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "riemann"))[1,])
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
plot(n.vec, riem.results)
points(n.vec, trap.results, pch = 5)
points(n.vec, R.resuls, pch = 7)
?plot
plot(n.vec, riem.results, ylim ylim = .499999999)
plot(n.vec, riem.results, ylim = .499999999)
plot(n.vec, riem.results, ylim = .49999)
plot(n.vec, riem.results, ylim = c(.50001, .4999))
plot(n.vec, riem.results, ylim = c(.50001, .49999))
plot(n.vec, riem.results, ylim = c(.500001, .499999))
points(n.vec, trap.results, pch = 5)
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 7/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "riemann"))[1,])
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
plot(n.vec, riem.results, ylim = c(.500001, .499999))
points(n.vec, trap.results, pch = 5)
points(n.vec, R.resuls, pch = 7)
riem.result
riem.results
Fapprox(10, "riemann")
Fapprox(100, "riemann")
Fapprox(1000, "riemann")
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 6/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "riemann"))[1,])
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
plot(n.vec, riem.results, ylim = c(.500001, .499999))
points(n.vec, trap.results, pch = 5)
points(n.vec, R.resuls, pch = 7)
riem.results
trap.results
Fapprox(10000, "riemann")
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 6/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- unlist((sapply(n.vec, Fapprox, "reimann"))[1,])
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 6/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # riemann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- (sapply(n.vec, Fapprox, "reimann"))
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
plot(n.vec, riem.results, ylim = c(.500001, .499999))
points(n.vec, trap.results, pch = 5)
points(n.vec, R.resuls, pch = 7)
riem.results
trap.results
R.resuls
integrand <- function(z) {
return(exp((-z^2)/2)/sqrt(2*pi))
}
Fapprox <- function(n, method){
# note that a is zero
h <- 6/n
i <- 0:(n-1)
if (method == "reimann") {
result <- sum(integrand(i*h)*h) # reimann
}
else if (method == "trapezoid") {
result <- sum(integrand(i*h)*h + (integrand((i+1)*h)-integrand(i*h))*h/2) # trapezoid
}
else { # I'll assume if you don't select one of the options above, or if you misspell something, you should use the base R
result <- integrate(integrand, lower = 0, upper = h*n , subdivisions = n) #base R
}
return(result)
}
n.vec <- c(10, 10^2, 10^3, 10^4)
types <- c("riemann", "trapezoid", "useR")
riem.results <- (sapply(n.vec, Fapprox, "reimann"))
trap.results <- (sapply(n.vec, Fapprox, "trapezoid"))
R.resuls     <- unlist((sapply(n.vec, Fapprox, "useR"))[1,])
riem.results
# note that all of the reimann estimates are greater than .5 given the negative monotonic slope of the integrand
# in addition, the best estimate (the highest n) is accurate up to four digits, while the worst (the lowest n) is
#   accurate up to zero digits.
trap.results
# with the trapezoid method, the best estimate is accurate up to ten digits, while the worst is accurate up to nine digits
R.resuls
# the native R function is better still with the best estimate also being accurate up to ten digits, but the worst is also accurate up to ten digits
options(digits = 16)
i <- -20:0
h <- 10^i
method.1 <- (exp(h) - exp(0))/h
method.2 <- (exp(h) - exp(-h))/(2*h)
plot(i, method.1, pch = 49)
points(i, method.2, pch =50)
method.1
1-method.1
(1-method.1)[5]
(1-method.1)[6]
?loh
?log
log10(100)
log10(.11)
log10(.011)
round(log10(.011))
round(log10(1-method.1))
round(log10(abs(1-method.1)))
abs(round(log10(abs(1-method.1))))
options(digits = 16)
i <- -20:0
h <- 10^i
method.1 <- (exp(h) - exp(0))/h
method.2 <- (exp(h) - exp(-h))/(2*h)
accuracy.1 <- abs(round(log10(abs(1-method.1))))
accuracy.2 <- abs(round(log10(abs(1-method.2))))
plot(i, accuracy.1, pch = 49)
points(i, accuracy.2, pch =50)
options(digits = 16)
i <- -20:0
h <- 10^i
method.1 <- (exp(h) - exp(0))/h
method.2 <- (exp(h) - exp(-h))/(2*h)
accuracy.1 <- abs(round(log10(abs(1-method.1))))
accuracy.2 <- abs(round(log10(abs(1-method.2))))
plot(i, accuracy.1, pch = 49, ylab = "Digits of accuracy")
points(i, accuracy.2, pch =50)
accuracy.2
options(digits = 16)
i <- -20:0
h <- 10^i
method.1 <- (exp(h) - exp(0))/h
method.2 <- (exp(h) - exp(-h))/(2*h)
accuracy.1 <- abs(round(log10(abs(1-method.1))))
accuracy.2 <- abs(round(log10(abs(1-method.2))))
plot(i, accuracy.2, pch = 50, ylab = "Digits of accuracy")
points(i, accuracy.1, pch =49)
exp(10)
exp(1)
exp(.001)
exp(.0001)
exp(.000001)
exp(.00000000001)
exp(.000000000001)
exp(.000000000000001)
exp(.0000000000000000001)
exp(.000000000000001)
exp(.000000000000001)-1
exp(.0000000000000001)-1
exp(10^-5)
exp(10^-4)
exp(10^-3)
getwd()
setwd("C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/642/SuperBowlBabies/SuperBowlBabies.git")
source('C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/642/SuperBowlBabies/SuperBowlBabies.git/Scripts/01 Initial processing.R', echo=TRUE)
source('C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/642/SuperBowlBabies/SuperBowlBabies.git/Scripts/02 Model implementation.R', echo=TRUE)
library(boot)
results.glm <- glm(changes ~ participated + won + poly(GDP..2009.dollars. , 3) , data = full.reg.data)
summary(results.glm)
cv.glm(full.reg.data, glmfit = results.glm)
cv.glm(full.reg.data, glmfit = results.glm)$delta
source('C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/642/SuperBowlBabies/SuperBowlBabies.git/Scripts/01 Initial processing.R', echo=TRUE)
source('C:/Users/Diag Davenport/Desktop/Edumacation, because degrees mean more than intelligence/Georgetown/642/SuperBowlBabies/SuperBowlBabies.git/Scripts/02 Model implementation.R', echo=TRUE)
